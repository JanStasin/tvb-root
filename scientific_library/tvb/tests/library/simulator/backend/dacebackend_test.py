# -*- coding: utf-8 -*-
#
#
#  TheVirtualBrain-Scientific Package. This package holds all simulators, and
# analysers necessary to run brain-simulations. You can use it stand alone or
# in conjunction with TheVirtualBrain-Framework Package. See content of the
# documentation-folder for more details. See also http://www.thevirtualbrain.org
#
# (c) 2012-2022, Baycrest Centre for Geriatric Care ("Baycrest") and others
#
# This program is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
# This program is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.  See the GNU General Public License for more details.
# You should have received a copy of the GNU General Public License along with this
# program.  If not, see <http://www.gnu.org/licenses/>.
#
#
#   CITATION:
# When using The Virtual Brain for scientific publications, please cite it as follows:
#
#   Paula Sanz Leon, Stuart A. Knock, M. Marmaduke Woodman, Lia Domide,
#   Jochen Mersmann, Anthony R. McIntosh, Viktor Jirsa (2013)
#       The Virtual Brain: a simulator of primate brain network dynamics.
#   Frontiers in Neuroinformatics (7:10. doi: 10.3389/fninf.2013.00010)
#
#

"""
Tests for the DaCe backend.

.. moduleauthor:: Marmaduke Woodman <marmaduke.woodman@univ-amu.fr>

"""


import unittest
import numpy as np
import dace

# NB seems dace wants module level definitions, not function locals
dims = 'svar cvar node hist'
n_svar, n_cvar, n_node, n_hist = [dace.symbol(f'n_{_}') for _ in dims.split(' ')]

# numba style, what DaCe calls "explicit dataflow"
@dace.program
def coupling_explicit(
        cX:      dace.float64[n_cvar, n_node],
        weights: dace.float64[n_node, n_node],
        state:   dace.float64[n_svar, n_hist, n_node],
        delay_indices: dace.int64[n_node, n_node]
        ):
    a = 0.00390625
    b = 0.0
    for i in dace.map[0:n_node]:
        cX[0,i] = 0
        cX[1,i] = 0
    for i, j in dace.map[0:n_node, 0:n_node]:
        cX[0,i] += weights[i,j] * state[0, delay_indices[i, j], j]
        cX[1,i] += weights[i,j] * state[1, delay_indices[i, j], j]
    for i in dace.map[0:n_node]:
        cX[0,i] = a * cX[0,i] + b
        cX[1,i] = a * cX[1,i] + b

# numba style, what DaCe calls "explicit dataflow"
@dace.program
def coupling_implicit(
        cX:      dace.float64[n_cvar, n_node],
        weights: dace.float64[n_node, n_node],
        state:   dace.float64[n_svar, n_hist, n_node],
        delay_indices: dace.int64[n_cvar, n_node, n_node]
    ):
    a = 0.00390625
    b = 0.0
    cX[:] = a * np.sum(weights * state.flat[delay_indices],axis=-1) + b


class TestDcCoupling(unittest.TestCase):

    def setUp(self) -> None:
        self.nn, self.nh = nn, nh = 76, 256
        self.state = np.random.randn(2, nh, nn)
        self.weights = np.random.randn(nn, nn)
        self.delay_indices = np.random.randint(0,256,(nn,nn))
        self.delay_indices_ = self.delay_indices * nn + np.tile(np.r_[:nn], (nn, 1))
        self.di2 = np.array([self.delay_indices_, self.delay_indices_ + nn*nh])
        return super().setUp()

    # adapted from the backend code gen shown below
    def coupling(self, cX, weights, state, delay_indices):
        n_svar = state.shape[0]
        n_cvar = cX.shape[0]
        n_node = cX.shape[1]
        assert cX.shape[1] == weights.shape[0] == weights.shape[1] == state.shape[2]
        a = 0.00390625
        b = 0.0
        for i in range(n_node):
            cX[0,i] = 0
            cX[1,i] = 0
        for i in range(n_node):
            for j in range(n_node):
                cX[0,i] += weights[i,j] * state[0, delay_indices[i, j], j]
                cX[1,i] += weights[i,j] * state[1, delay_indices[i, j], j]
        for i in range(n_node):
            cX[0,i] = a * cX[0,i] + b
            cX[1,i] = a * cX[1,i] + b

    def test_explicit(self):
        cx1, cx2 = np.zeros((2, 2, self.nn))
        cx2 = np.copy(cx2)
        self.coupling(cx1, self.weights, self.state, self.delay_indices)
        coupling_explicit(cx2, self.weights, self.state, self.delay_indices)
        np.testing.assert_allclose(cx1, cx2)
    
    def test_implicit(self):
        cx1, cx2 = np.zeros((2, 2, self.nn))
        cx2 = np.copy(cx2)
        self.coupling(cx1, self.weights, self.state, self.delay_indices)
        coupling_implicit(cx2, self.weights, self.state, self.di2)
        np.testing.assert_allclose(cx1, cx2)        
 

def _def_mpr_kernels(self):
    """
    These are kernels for MPR sim generated by the NumPy backend.  Since
    DaCe is a bit new, it's easier to adapt these kernels to DaCe and then
    later do templating and cross testing.

    """
    import numpy as np

    sin, cos, exp = np.sin, np.cos, np.exp

    def coupling(cX, weights, state, delay_indices
                ):
        n_svar = state.shape[0]
        n_cvar = cX.shape[0]
        n_node = cX.shape[1]
        assert cX.shape[1] == weights.shape[0] == weights.shape[1] == state.shape[2]
        a = 0.00390625
        b = 0.0
        x_j = state[0].flat[delay_indices]
        gx = np.sum(weights * (x_j), axis=-1)
        cX[0, :] = a * gx + b
        x_j = state[1].flat[delay_indices]
        gx = np.sum(weights * (x_j), axis=-1)
        cX[1, :] = a * gx + b

    def dfuns(dX, state, cX, parmat):
        tau = 1.0
        Delta = 1.0
        J = 15.0
        I = 0.0
        cr = 1.0
        cv = 0.0
        eta = parmat[0]
        pi = np.pi
        Coupling_Term_r, Coupling_Term_V = cX
        r, V = state
        dX[0] = 1/tau * (Delta / (pi * tau) + 2 * V * r)
        dX[1] = 1/tau * (V*V - pi*pi*tau*tau*r*r + eta + J * tau *
                        r + I + cr * Coupling_Term_r + cv * Coupling_Term_V)

    def integrate(state, weights, parmat, dX, cX, delay_indices
                ):
        dt = 0.01
        coupling(cX, weights, state, delay_indices)
        dfuns(dX[0], state[:, 0], cX, parmat)
        dfuns(dX[1], state[:, 0] + dt * dX[0], cX, parmat)
        next_state = state[:, 0] + dt / 2 * (dX[0] + dX[1])
        state[:] = np.roll(state, 1, axis=1)
        state[:, 0] = next_state

    def kernel(state, weights, trace, parmat, idelays):
        n_node = 76
        n_svar = 2
        n_cvar = 2
        nt = 10
        dX = np.zeros((2, n_svar, n_node))
        cX = np.zeros((n_cvar, n_node))
        for t in range(nt):
            integrate(state, weights, parmat, dX, cX, idelays
                    )
            trace[t] = state[:, 0].copy()
    
    return coupling, dfuns, integrate, kernel
